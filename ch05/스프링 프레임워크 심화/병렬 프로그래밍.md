# Sync, Async vs Blocking, Non-Blocking

## Sync, Async
Sync 방식  
![image](https://user-images.githubusercontent.com/67637716/155871292-c39a07b7-c0e1-4afe-918d-10dc8fd9e33d.png)
메서드는 결과가 완성될 때까지 반환을 하지 않는다.  

Async방식  
![image](https://user-images.githubusercontent.com/67637716/155871322-d5aed60e-44c0-40c5-a990-b4eb967e68a4.png)
결과값이 결정되기 전에 일단 반환을 한다.  
원하는 return 값을 찾기 전에 일단 빈값을 넘긴다.  
클라이언트에서는 최종 결과를 받기전에 메서드로 부터 임시로 반환을 받는다.  
그렇다면 클라이언트는 최종결과값을 어떻게 알 수 있을까?  


## Blocking, Non-Blocking
Sync, Asnyc는 메서드를 제공하는 곳에서의 입장에 대한 것이라면, Blocking, Non-Blocking은 메서드를  
호출(사용)하는 곳, 즉 클라이언트에서의 입장에 대한 것이다.  
![image](https://user-images.githubusercontent.com/67637716/155871380-fb68665a-2da0-4b7a-8c1e-8813e71d4c74.png)
Async메서드는 결과를 완성하기 전에 일단 반환을 한다.  
클라이언트는 다른 작업을 수행할 수 있다.  
하지만 return값이 필요한 시점에서 getPriceAsync의 결과를 알고 싶을 때에는 다시 데이터를 조회해야한다.  
클라이언트 입장에서는 항상 논블록킹이 아닌상태이다. (데이터 조회시 Blocking)

### 콜백 함수를 구현
논-블록킹 환경으로 개선하기 위해서는 콜백 함수를 구현해야 한다.  
메서드를 제공하는 곳에서 결과가 완성되면 클라이언트로 결과가 나왔다고 알려주는 방법이다.  
![image](https://user-images.githubusercontent.com/67637716/155871528-0c7d3590-751b-4c89-bf6f-f25925d73021.png)


# Thread Pool
순차 프로그래밍 샘플
``` java
private static void task() {
		try {
			Thread.sleep(1000);
		} catch (InterruptedException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}
  
  IntStream.range(0, 100).forEach(n -> {
    String threadName = Thread.currentThread().getName();
    System.out.println(threadName + ":task start" + n);
    task();
    System.out.println(threadName + ":task completed" + n);
```

해당 메서드를 100번 실행하면 단 하나의 쓰레드(main 쓰레드)로 모든 작업을 순차적으로 처리하기 때문에 100초의 시간이 걸릴 것이다.  
짧은 시간에 모든 작업이 완료될 수 있도록 '병렬 프로그래밍'으로 개선한다.  
Executors.newFixedThreadPool 메서드를 사용해 쓰레드풀을 정의한다.  
``` java
private static final int THREAD_POOL_SIZE = 100;
	 
	private static final Executor EXECUTOR =
			Executors.newFixedThreadPool(THREAD_POOL_SIZE);
```

ThreadPool 종류
![image](https://user-images.githubusercontent.com/67637716/155871948-2aa630d0-dd13-4c50-b9ee-9af38281130d.png)

``` java
public static ExecutorService newFixedThreadPool(int nThreads) {
        return new ThreadPoolExecutor(nThreads, nThreads,
                                      0L, TimeUnit.MILLISECONDS,
                                      new LinkedBlockingQueue<Runnable>());
    }
```
ThreadPoolExcutor을 사용해서 커스텀 쓰레드풀도 만들 수 있다.  

Executor을 활용해서 병렬로 동시에 실행하는 로직이다.  
``` java
IntStream.range(0,100).forEach(n->EXECUTOR.execute(()->{
		 String threadName = Thread.currentThread().getName();
		    System.out.println(threadName + ":task start" + n);
		    task();
		    System.out.println(threadName + ":task completed" + n);
	});
```

