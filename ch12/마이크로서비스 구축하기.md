### 마이크로서비스 예제를 먼저 작성해 본다.
1. random한 5개의 number목록을 만들어주는 service  
``` java
spring.application.name=microservice-a

@Slf4j
@RestController
public class RandomNumberController {
	@RequestMapping("/random")
	public List<Integer> random() {
		List<Integer> numbers = new ArrayList<>();
		IntStream.rangeClosed(1, 5).forEach(num -> {
			numbers.add(generateRandomNumber());
		});

		log.info("Returning :::" + numbers);
		return numbers;

	}

	private int generateRandomNumber() {
		return (int) (Math.random() * 1000);
	}
}

```  

2. microservice-a에서 랜덤 목록 서비스를 소비하는 서비스  
``` java
server.port=8100
spring.application.name=service-consumer
number.service.url=http://localhost:8080/random

@Slf4j
@RestController
public class NumberAdderController {

	@Value("${number.service.url}")
	private String numberServiceUrl;

	@RequestMapping("/add")
	public Long add() {
		long sum = 0;

		ResponseEntity<Integer[]> responseEntity = new RestTemplate().getForEntity(numberServiceUrl, Integer[].class);

		Integer[] numbers = responseEntity.getBody();

		for (int number : numbers) {
			sum += number;
		}

		log.warn("Returning :::" + sum);
		return sum;
	}
}
```

http://localhost:8100/add url을 호출하면 microservice-a에서 random 목록이 리턴되고, 서비스 소비자의 add 서비스를 추가해 리턴받는다.  

# 마이크로서비스에 클라우드 네이티브 기능 추가
6개의 서로다른 마이크로서비스 애플리케이션과 구성요소를 만들기 위해 특정 애플리케이션에 특정 포트를 사용.  
![image](https://user-images.githubusercontent.com/67637716/159279939-6eb2bc6a-3dbd-4d01-a3eb-f46f673d6caf.png)

## 중앙 집중식 마이크로서비스 구성
다른 마이크로서비스에 관한 구성을 별도로 유지하면 운영이 어려워질 수 있다.  
솔루션은 중앙 집중식 컨피그 서버를 만드는 것이다.  
![image](https://user-images.githubusercontent.com/67637716/159283647-27ed7d05-afe1-4799-9249-48358e47c6e2.png)  
중앙 집중식 컨피그 서버는 서로 다른 모든 마이크로서비스에 속한 모든 구성을 보유한다.  
Spring Initializer에서 제공되는 옵션  
![image](https://user-images.githubusercontent.com/67637716/159284133-014c65b9-3032-4bf2-9599-0e1eb9ddf7b1.png)  
주키퍼와 콘솔이 좋은 대안이지만, 가장 인기있는 옵션은 Spring-cloud-config다. (Config Client)  

### 스프링 클라우드 컨피그
스프링 클라우드 컨피그는 중앙 집중식 마이크로서비스 구성을 지원한다.  
두 가지 중요한 구성요소의 조합이다.  
* 스프링 클라우드 컨피그 서버 
	* 버전 관리 레파지토리(GIT 또는 하위 버전)에 의해 백업 된 중앙 집중식 구성 노출을 지원
* 스프링 클라우드 컨피그 클라이언트 
	* 애플리케이션이 스프링 클라우드 컨피그 서버에 연결하도록 지원

여러 마이크로서비스 구성은 단일 깃 레파지토리에 저장.  
![image](https://user-images.githubusercontent.com/67637716/159285509-92ff839e-0e4d-4ffc-a549-a4706f12e5ff.png)  

### 스프링 클라우드 컨피그 서버 구현
스프링 클라우드 컨피그를 구현하려면 다음 단계가 필요하다.  
1. 클라우드 컨피그 서버 설정
2. 마이크로서비스-a에 서비스를 새로 만들어 애플리케이션 구서으이 일부 정보 리턴, 서비스로 스프링 클라우드 컨피그 서버에서 구성을 선택할 수 있는지 테스트
3. 로컬 깃 레파지토리를 설정하고 스프링 클라우드 컨피그 서버에 연결
4. 스프링 클라우드 컨피그 클라이언트를 사용해 클라우드 컨피그 서버의 구성을 사용하도록 마이크로서비스-a를 업데이트

#### 1. 스프링 클라우드 컨피그 서버 설정
컨피그 서버 dependency 추가, EnableConfigServer 어노테이션 추가    
``` java
<dependency>
	<groupId>org.springframework.cloud</groupId>
	<artifactId>spring-cloud-config-server</artifactId>
</dependency>


@EnableConfigServer
@SpringBootApplication
public class ConfigServerApplication {

	public static void main(String[] args) {
		SpringApplication.run(ConfigServerApplication.class, args);
	}

}
```  

#### 2. 애플리케이션 구성에서 메시지를 반환하기 위해 마이크로서비스-a에 서비스 생성
application.properties에서 간단한 메시지를 반환하는 서비스 만든다.  

``` java
application.message=Default Message

@Configuration
@Setter
@Getter
@ConfigurationProperties("application")
public class ApplicationConfiguration {
	private String message;
}

@RestController
public class MessageController {

	@Autowired
	ApplicationConfiguration configuration;

	@RequestMapping("/message")
	public Map<String, String> welcome() {
		Map<String, String> map = new HashMap<>();
		map.put("message", configuration.getMessage());
		return map;
	}
}

http://localhost:8080/message
{
  "message": "Default Message"
}

```

#### 3. 스프링 클라우드 컨피그 서버를 로컬 깃 레파지토리에 연결
킁라우드 컨피그 서버가 깃 레파지토리에서 구성을 선택하기를 원하므로 시작하기 위해선 깃 레파지토리를 설정해야한다.  
``` java
management.security.enabled=false
application.message=Message From Default Local Git Repository
```
위의 내용으로 깃 레파지토리에 마이크로서비스-a의 구성을 추가, add, commit
![image](https://user-images.githubusercontent.com/67637716/159290121-e34f584b-e691-4daf-82c1-d396940717d5.png)

config-server에서 application.properties 구성
``` java
spring.application.name=config-server

server.port=8888

# 로컬 깃 레파지토리의 uri구성
# 원격 깃 레파지토리에 연결하려면 여기에서 깃 레파지토리의 uri를 구성해야함
spring.cloud.config.server.git.uri=file://C:/gb_0900_msh/tobySpring/resource/sts-4.13.1.RELEASE/workspace/git-localconfig-repo

```

서버를 시작하고 http://localhost:8888/microservice-a/default 요청을 보내면 아래와 같은 응답이 표시된다.  
![image](https://user-images.githubusercontent.com/67637716/159292230-871f8b55-3c4c-48cc-b823-ea0a36d8e441.png)

URI 포멧은 /{application-name}/{profile}[/{label}]이다.  
기본 프로파일을 사용하고 있으므로 서비스는 microservice-a.properties에서 구성을 반환한다.  
propertySource>name 필드에서 확인할수 있다.  
source : 응답내용은 속성 파일의 내용.  

git-localconfig-repo에서 이름이 microservice-a-dev.properties인 새파일 생성  
![image](https://user-images.githubusercontent.com/67637716/159293653-b6d1cb9a-6974-4613-8a66-0f46e7bb6c99.png) 
git add, git commit  
http://localhost:8888/microservice-a/dev 요청  
![image](https://user-images.githubusercontent.com/67637716/159295083-00ddf32a-2b95-4f3f-af2a-936412e9d3ac.png)  
microservice-a-dev.properties에 구성된 속성은 microservice-a.properties에 구성된 기본값보다 우선순위가 높다.  

dev와 마찬가지로 마이크로서비스A에 대한 별도의 구성을 다양한 환경에 맞게 만들수 있다.  
클라우드 컨피그 서버의 마이크로서비스A의 애플리케이션 구성이 준비되었다.  
마이크로서비스A를 클라우드 컨피그 서버에 연결해보자.  

### 마이크로서비스A를 스프링 클라우드 컨피그 클라이언트로 만들기  


