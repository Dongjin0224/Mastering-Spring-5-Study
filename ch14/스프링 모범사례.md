<h1> 스프링 모범 사례 </h1>

* 엔터프라이즈 애플리케이션의 구조
* 스프링의 구성
* 의존 관계 버전 관리
* 예외 처리
* 단위 테스트
* 통합 테스트
* 세션 관리
* 캐싱
* 로깅

#### 메이븐 표준 디렉토리 레이아웃
  
![image](https://user-images.githubusercontent.com/43237961/160350697-128ad95d-ce0b-4f26-bac4-d9d80bb49d85.png)  

  


- src/main/webapp : 웹 애플리케이션과 관련된 모든 리소스, 뷰 파일 (jsp, 뷰 템플릿, 정적 콘텐츠)
- src/test/resource : 단위 테스트와 관련된 모든 리소스

#### 레이어 아키텍처를 사용한 애플리케이션 구축 
핵심 설계 목표 중 하나는 SoC(seperation of Concerns)이다. - 관심사의 분리  
애플리케이션이나 마이크로서비스의 크기와 관계없이 레이어 아키텍처를 만드는 것이 좋다.  

애플리케이션을 레이어화하면 단위 테스트가 단순해진다. 레이어의 코드마다 다음 레이어를 모킹해 단위 테스트를 완벽하게 수행할 수 있다.  

* 다른 레이어를 위한 별도의 컨텍스트 파일
  * 레이어마다 다른 스프링 컨텍스트를 사용하는 것이 좋다. 각 레이어의 문제를 분리하는 데 도움이 되며 특정 레이어의 코드를 단위 테스트할 때도 도움이 된다.
  * application-context.xml 
  * presentation-context.xml - PresentationConfig.java
  * services-context.xml - ServicesConfig.java
  * business-context.xml - BusinessConfig
  * persistence-context.xml
  

#### 예외 처리 모범 사례
- 체크된 예외 : 서비스 메소드가 체크된 예외를 발생시키면 모든 소비자 메소드가 예외를 처리하거나 예외를 발생시켜야 한다. (ex try-catch)
- 언체크된 예외 : 소비자 메소드는 서비스 메소드에 의해 발생한 예외를 처리하거나 발생시킬 필요가 없다. (ex. RuntimeException)

RuntimeException과 모든 서브 클래스는 언체크된 예외이며 다른 모든 예외는 체크된 예외다. 

```java
try{
    File file = new File("my/file/path");
    FileInputStream fis = new FileInputStream(file);   
}catch(FileNotFoundException e){

}
```

* 예외 처리에 대한 스프링의 접근 방식
  * 스프링의 예외 대부분은 언체크돼 있어 코드가 단순해진다.
```java
jdbcTemplate.udpate(INSERT, bean.getDescription, bean.isDone());

```

* 권장 예외 처리 방법
  * 소비자를 생각해보자. 메소드 소비자가 예외에 대해 유용한 작업을 수행할 수 없는 경우 ( 로깅 또는 에러 페이지 표시 제외) 예외 발생 처리를 하지 않는다. (언체크된 예외 제외)
  * ex. catch(exception e) e.printstacktrace(); / log.error("error has caught", e);
  * 최상위 레이어 (일반적으로 프레젠테이션 레이어) 에서는 에러 페이지를 표시하거나 소비자에게 에러 응답을 보내려면 모든 예외 처리를 잡아야 한다.  


* 스프링 구성 간결하게 유지
  * 어노테이션 이전의 스프링 문제는 애플리케이션 컨텍스트 XML 파일의 크기였다.
  * 어노테이션을 사용하면서 긴 애플리케이션 컨텍스트 XML 파일이 더 이상 필요하지 않게 됐다. 
  * 빈을 수동으로 XML 파일에 연결하는 대신, 컴포넌트 스캔을 사용해 빈을 찾고 오토와이링하는 것이 좋다. 
  * 애플리케이션 컨텍스트 XML 파일은 간결하게 유지해야 한다. 
  * 프레임워크 관련 구성이 필요할 때마다 자바 @Configuration을 사용하는 것이 좋다. 


#### ComponentScan 에서 basePackageClasses 속성 사용
- 컴포넌트 스캔을 사용할 때 basePackageClasses 속성을 사용하는 것이 좋다. 
```java
@ComponentScan(basePackageClasses = ApplicationController.class)
public class SomeApplication { 
```
basePackageClasses 속성은 basePackages()의 type-safe 대안이며 어노테이션이 달린 컴포넌트를 스캔할 패키지를 지정하는 데 사용할 수 있다.  


#### 필수 의존 관계에 생성ㅇ자 주입 선호
- 필수 의존 관계 : 빈에 사용하려는 의존관계다. 의존 관계를 사용할 수없을 때는 컨텍스 로드되지 않는 편이 좋다.  - 생성자 주입

- 선택적 의존 관계 : 이들은 선택적 의존 관계로 항상 이용할 수 있지는 않다. 컨텍스트를 사용할 수 없는 경우에도 컨텍스트를 로드하는 것이 좋다. -setter 주입

setter 주입 대신 생성자 주입을 사용해 필수 의존 관계를 연결하는 것이 좋다.  
필수 의존관계가 누락되면 컨텍스트가 로드되지 않도록 한다. 

```java
public class SomeClass() {
private MandotoryDependency mandatoryDependency;
private OptionalDependency optionalDependency;

public someClass(MandatoryDependency mandatoryDependency) {
this.mandatoryDependency = mandatoryDependency;
}

public void setOptionalDependency(OptionalDependency optionalDependency) {
this.optionalDependency =  optionalDependency;
}
```

#### 스프링 프로젝트의 의존 관계 버전 관리 
프로젝트는 의존 관게라고도 하는 다른 프레임워크에 의존한다. 사용되는 프레임워크 의존 관계 버전을 관리하는 것은 중요하다.   
스프링 부트를 사용할 떄 의존 관계 버전을 관리하는 가장 간단한 옵션은 spring-boot-starter-parent를 부모 POM으로 사용하는 것이다.  

```java 
<parent>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-parent</artifactId>
    <version>${spring-boot.version}</version>
</parent>
``` 

200개가 넘는 의존 관계의 버전은 spring-boot-starter-parent에서 관리한다. 스프링부트가 릴리스되기 전에는 의존 관계버전이 모두 잘 작동되는 것을 보장한다.   
