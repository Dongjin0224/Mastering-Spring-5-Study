# 리액티브 프로그래밍
리액티브 프로그래밍은 함수형 프로그래밍을 기반으로 대체 스타일을 제공한다.

-----------------

## 함수형 프로그래밍
함수형 프로그래밍은 하나의 프로그래밍 패러다임으로 정의되는 일련의 코딩 접근 방식이며,

자료처리를 수학적 함수의 계산으로 취급하고 상태와 가변 데이터를 멀리하는 프로그래밍 패러다임을 의미한다.

최근의 프로그래밍 패러다임은 크게 아래와 같이 구분할 수 있다.

* 명령형 프로그래밍 : 무엇(What)을 할 것인지 나타내기보다 어떻게(How) 할 건지를 설명하는 방식
  * 절차지향 프로그래밍 : 수행되어야 할 순차적인 처리 과정을 포함하는 방식 (C, C++)
  * 객체지향 프로그래밍 : 객체들의 집합으로 프로그램의 상호작용을 표현 (C++, java, C#)
  
* 선언형 프로그래밍 : 어떻게 할건지(How)를 나타내기보다 무엇(What)을 할 건지를 설명하는 방식
  * 함수형 프로그래밍 : 순수 함수를 조합하고 소프트웨어를 만드는 방식 (클로저, 하스켈, 리스프)
  
![programming-language](https://user-images.githubusercontent.com/82895809/159193132-4a2afafa-3989-4f28-b242-ea1ef9992d2b.png)

명령형 프로그래밍을 기반으로 개발했던 개발자들은 개발하는 소프트웨어의 크기가 커짐에 따라,

복잡하게 엉켜있는 스파게티 코드를 유지보수하는 것이 매우 힘들다는 것을 깨닫게 되었다.

그리고 이를 해결하기 위해 함수형 프로그래밍이라는 프로그래밍 패러다임에 관심을 갖게 되었다.

함수형 프로그래밍은 거의 모든 것을 순수 함수로 나누어 문제를 해결하는 기법으로,

작은 문제를 해결학디 위한 함수를 작성하여 가독성을 높이고 유지보수를 용이하게 해준다.

[함수형을 적용하지 않은 코드]
```
public class WordCount {

    private static List<String> WORDS = Arrays.asList("TONY", "a", "hULK", "B", "america", "X", "nebula", "Korea");

    private static Map<String, Integer> wordPrefixFreq() {
        Map<String, Integer> wordCountMap = new HashMap<>();
        String prefix;
        Integer count;

        for (String word : WORDS) {
            prefix = word.substring(0, 1);
            count = wordCountMap.get(prefix);
            if (count == null) {
                wordCountMap.put(prefix, 1);
            } else {
                wordCountMap.put(prefix, count + 1);
            }
        }

        return wordCountMap;
    }

    public static void main(String[] args) {
        final Map<String, Integer> map = wordPrefixFreq();
        map.keySet()
            .forEach(k -> System.out.println(k + ": " + map.get(k)));
    }
}
```
함수형 프로그래밍을 적용하지 않은 코드에서는 List를 루프를 돌면서 접두사를 잘라내고 그 갯수를 Map에 저장하고 있다.

위의 코드는 최선일 것 같아 보이지만 함수형 프로그래밍 기법을 적용하면 더욱 간결하고 가독성있게 코드를 변경할 수 있다.

[함수형을 적용한 코드]
```
public class WordCount {
    private static List<String> WORDS = Arrays.asList("TONY", "a", "hULK", "B", "america", "X", "nebula", "Korea");

    private static Map<String, Integer> wordPrefixFreq() {
        Map<String, Integer> wordCountMap = new HashMap<>();
        WORDS.stream()
            .map(w -> w.substring(0, 1))
            .forEach(prefix -> wordCountMap.merge(prefix, 1, (oldValue, newValue) -> (newValue += oldValue)));
        return wordCountMap;
    }

    public static void main(String[] args) {
        final Map<String, Integer> map = wordPrefixFreq();
        map.keySet()
            .forEach(k -> System.out.println(k + ": " + map.get(k)));
    }
}

```
위의 코드는 stream()을 통해 함수형 프로그래밍을 위한 Stream 객체를 생성하고 있고,

map()을 통해 Stream 객체의 단어들을 prefix로 변형시키고 있다. 

그리고 foreach를 통해서 prefix를 보고 map에 값을 추가하고 있다.

-----------------

마이크로 서비스 아키텍처는 메시지 기반 통신을 선호한다.

리액티브 프로그래밍의 중요한 특징은 이벤트(또는 메시지)를 중심으로 애플리케이션을 구축하는 것이다.

몇 년 전부터 대부분의 애플리케이션에는 다음과 같은 특징이 있다.
* 수 초 단위의 응답 시간
* 여러 시간의 오프라인 유지 관리
* 소량의 데이터

시대가 바뀌면서 오늘 날에는 다음과 같은 특징이 있다.
* 밀리초 단위의 응답 시간
* 100% 가용성
* 데이터 볼륨이 기하 급수적으로 증가

지난 몇 년 동안 이러한 새로운 도전 과제를 해결하기 위해 다양한 접근 방식이 등장했다.

리액티브 프로그래밍은 실제로 새로운 현상은 아니짐나 문제를 성공적으로 해결한 접근법 중 하나다.

--------------

리액티브 방식으로 구축된 시스템은 보다 유연하고 느슨하게 연결되며 확장 가능하므로 개발하거나 변경이 쉽다.

이들은 장애에 훨씬 더 관대해 장애가 발생하면 큰 장애를 일으키지 않고 간결하게 대처한다.

리액티브 시스템은 반응이 뛰어나 사용자에게 효과적인 대화식 피드백을 제공한다.

--------------

## 리액티브 시스템의 특성
![3](https://user-images.githubusercontent.com/82895809/159194538-d6a0ce73-5b77-484c-80f2-c073520c6a67.jpg)
![4](https://user-images.githubusercontent.com/82895809/159194541-9c48690d-02eb-424f-8e41-df3950f3cf63.jpg)

